color_t noisy_sample(Material_t *mtrl, vfloat_t x, vfloat_t y)
{
    const vfloat_t WAV_LEN = TILE_SIZE * 1.5;
    const vfloat_t AMP = TILE_SIZE / 2;
    vfloat_t oldY = y;
    y = y + AMP * cos(PI2 * x / WAV_LEN / 2) / 2;
    x = x + AMP * cos(PI2 * oldY / WAV_LEN / 2) / 2;

    int tx = (int)floor(x / TILE_SIZE);
    int ty = (int)floor(y / TILE_SIZE);
    srand(tx);
    /* fix for srand(0) and srand(1) having same effect in glibc */
    if (tx == 0)
        srand(rand());
    srand(ty + rand());

    /* generate a random, fully-saturated color */
    color_t out_color;
    int low_i = rand() % 3;
    int high_i = (rand() % 2 + 1 + low_i) % 3;
    int mid_i = 2 * (low_i + high_i) % 3;
    out_color.c[low_i] = 0;
    out_color.c[high_i] = 1;
    out_color.c[mid_i] = rand() / (clrfloat_t)RAND_MAX;
    return out_color;
}

color_t concentric_sample(Material_t *mtrl, vfloat_t x, vfloat_t y)
{
    const color_t GREY = {{ 0.2, 0.2, 0.2 }};
    const color_t GREEN = {{ 0, 1, 0 }};
    const vfloat_t THICK = 2;
    struct vec3 P1 = {{ -10, -40, 0 }}, P2 = {{ 30, 50, 0 }};
    struct vec3 xyv = {{ x/2, y/2, 0 }};
    vfloat_t r1 = v3_magnitude(v3_sub(P1, xyv)) / THICK / 2;
    vfloat_t r2 = v3_magnitude(v3_sub(P2, xyv)) / THICK / 2;
    vfloat_t scale = cos(PI2 * r1) + cos(PI2 * r2);
    scale = (scale + 2)/4;
    return clr_add(clr_scale(GREY, scale), clr_scale(GREEN, 1-scale));
}
