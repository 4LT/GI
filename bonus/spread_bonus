
color_t reflect(intersect_result_t res)
{
    if (res.depth == 0)
        return CLR_BLACK;

    color_t out_color = CLR_BLACK;
    Material_t *mtrl = res.material;
    struct vec3 normal = res.normal;

    /* axis-aligned vector such that (aa x normal) is never (0, 0, 0) */
    struct vec3 aa = (struct vec3) {{ 1, 0, 0 }};
    if (fabs(normal.v[0]) > fabs(normal.v[1]))
        aa = (struct vec3) {{ 0, 1, 0 }};

    struct vec3 unit_x = v3_normalize(v3_cross(normal, aa));
    struct vec3 unit_y = v3_cross(normal, unit_x);
    
    const bool UNIFORM = false;
    for (int i = 0; i < mtrl->reflect_ray_count; i++) {

        float theta = PI2 * rand_float();
        float r = rand_float();
        if (UNIFORM) r = sqrt(r);
        r*= mtrl->roughness;
        struct vec3 mod_normal = v3_add(normal, v3_add(
                v3_scale(unit_x, r * cos(theta)),
                v3_scale(unit_y, r * sin(theta)) ));
        mod_normal = v3_normalize(mod_normal);
                  
        struct vec3 proj_i = v3_project(mod_normal, res.incoming);
        struct vec3 proj_r = v3_add(proj_i,
                v3_scale(v3_sub(mod_normal, proj_i),2));
        ray_t reflected_ray;
        reflected_ray.direction = v3_normalize(proj_r);
        reflected_ray.position = v3_add(res.position,
                v3_scale(normal, FUDGE));
        
        color_t reflect_color = color_at_rec(*(mtrl->scene), reflected_ray,
                res.depth - 1);
        out_color = clr_add(out_color, reflect_color);
    }
